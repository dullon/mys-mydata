57 : 只针对异常的情况才使用异常

 try {
            int i = 0;
            while (true){
                range[i++].climb();
            }
        }catch (ArrayIndexOutOfBoundsException e){

        }
    这段代码明显是想让数组一致遍历，直到边界，继续遍历，然后数组越界，此时被异常捕获，遍历终止。虽然也能达到目的，但这么做很容易引起人误解，并且方法也不规范，我们完全可以使用for循环来处理。
for(ang m : range){
            m.climb();
        }
    为什么优先异常的模式,而不是用行之有效标准模式呢?
    可能被误导了,企图利用异常机制提高性能,因为jvm每次访问数组都需要判断下标是否越界,他们认为循环终止被隐藏了,但是在foreach循环中仍然可见，这无疑是多余的,应该避免.
    上面想法有三个错误:
    1.异常机制设计的初衷是用来处理不正常的情况,所以JVM很少对它们进行优化。
    2.代码放在try..catch中反而阻止jvm本身要执行的某些特定优化。
    3.对数组进行遍历的标准模式并不会导致冗余的检查。

    基于异常模式模糊了代码意图,降低它的性能,并且无法保证正常工作!如果出现bug,模式可能会悄悄失效,并且掩盖这个bug,增加调试过程的复杂性.假设循环中调用某个方法执行不相关数组的越界异常访问,使用合理模式,可以获得完整的异常链,如果基于异常模式,这个bug会捕获到,但是被误解为正常循环终止条件.

   良好的API设计不应该强迫它的客户端为了正常的控制流而使用异常。
   总之，异常是为了在异常情况下使用而设计的，不是为了普通控制使用的。


58 ：对可恢复的情况使用受检异常，对编程错误使用运行时异常

    java 程序设计语言可抛出三种结构（Throwable）：受检异常(Checked Excepction)、运行时异常(RunTimeException)、错误(Error)。
    在决定使用受检的异常或是或受检的异常时，主要的原则是：如果期望调用者能够适当恢复，对于这种情况就应该使用受检的异常。通过抛出受检的异常，强迫调用者在一个catch字句中处理该异常，或者将它传播除去。因此，方法中声明要抛出的每个受检的异常，都是对API用户的一种潜在指示：与异常相关联的条件是调用这个方法的一种可能的结果。

    有两种未受检的可抛出结构：运行时异常和错误。在行为上两者是等同的：它们都不需要也不应该被捕获的可抛出结构。如果程序抛出未受检的异常或者错误，往往就属于不可恢复的情形，继续执行下去有害无益。如果程序没有捕捉到这样的可抛出结构，将会导致当前线程停止，并出现适当的错误消息。
    用运行时异常(RunTimeException)来表明编程错误。大多数的运行时异常都表示前提违例。所谓前提违例是指API的客户没有遵守API规范建立的约定。例如数组访问越界(ArrayIndexOutOfBoundsException)等。
    错误(Error)表示系统级的错误和程序不必处理的异常，是java运行环境中的内部错误或者硬件问题，比如，内存资源不足、操作系统出错。在大多数情况下，当遇到这样的错误时，建议让该程序中断。这样的异常超出了程序可控制的范围。

    总而言之，对于可恢复的情况，使用受检的异常；对于程序错误，则使用运行时异常。有时候并不是那么的黑白分明，如果你相信有一种情况可能允许恢复，就使用受检异常。如果不清楚是否能恢复，就使用未受检的异常。