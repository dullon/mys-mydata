63 ： 在细节消息中包含能捕获失败的信息

    当程序由于未被捕获的异常而失败的时候，系统会自动打印该异常的信息，在堆栈中包含该异常的字符串表示法，即它的toString方法的调用结果，包含了一系列信息：该异常的类名和细节消息。基本上，这是程序员在调查程序失败原因的必要的信息。如果这个失败不易重现，这失败的信息就异常重要，异常的细节消息应该捕获住失败，便于以后分析。

    为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。每一种情形都代表了不同的问题，如果程序员知道应该去查找那种错误，就可以极大的加速诊断过程。

    为了确保在异常的细节信息中包含足够的能捕获失败的信息，一种办法是在异常的构造器而不是字符串细节消息中引入这些消息。然后，有了这些信息，只要把他们放到消息描述中，就可以自动产生细节消息。

    遗憾的是，Java平台类库并没有广泛的使用这种做法，但是，这种做法仍然值得大力推荐。他使程序员更加易于抛出异常以捕获失败。实际上，这种做法使程序员不像捕获失败都难！这种做法可以有效地把代码集中起来放在异常类中，由这些代码对异常类自身中的异常产生高质量的细节消息，而不是要求类的每个用户都多余的产生细节信息。

    （同58条的建议）为异常的“失败捕获”信息提供一些访问方法是合适的提供一些访问方法是合适的。提供这样的访问方法对于受检的异常，比对于未受检的异常更为重要，因为失败——捕获信息对于从失败中恢复是非常有用的。程序员希望通过程序的手段来访问未受检异常的细节，这很少见（尽管也是可以想象得到的）。然而，即使对于未受检的异常，作为一般原则提供这些访问方法也是明智的。（见10条）


64 ： 努力使失败保持原子性

    当对象抛出异常之后，通常我们期望这个对象仍然保持在一种定义良好的可用状态之中，即使失败是发生在执行某个操作的过程中间。对于受检的异常而言，这尤为重要，因为调用者期望能从这种异常中进行恢复。一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法被称为具有失败原子性。

    有几种途径可以实现这种效果。
    1 最简单的办法莫过于设计一个不可变的对象（见第15条：使可变性最小化）。如果对象是不可变的，失败原子性就是显然的。如果一个操作失败了，它可能会阻止创建新的对象，但是永远也不会使已有的对象保持在不一致的状态之中，因为当每个对象被创建之后它就处于一致的状态之中，以后也不会再发生变化。

    2 对于在可变对象上执行操作的方法，获得失败原子性最常见的办法是，在执行操作之前检査参数的有效性（见第38条：检查参数的有效性）。这可以使得在对象的状态被修改之前，先抛出适当的异常。

    3 一种类似的获得失败原子性的办法是，调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。如果对参数的检査只有在执行了部分计算之后才能进行，这种办法实际上就是上一种办法的自然扩展。

    4 编写一段恢复代码(recovery code),由它来拦截操作过程中发生的失败，以及使对象回滚到操作开始之前的状态上。这种办法主要用于永久性的(基于磁盘的(disk-based))数据结构。(很不常用)

    5 在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。如果数据保存在临时的数据结构中，计算过程会更加迅速，使用这种办法就是件很自然的事。例如，Collections.sort在执行排序之前，首先把它的输入列表转到一个数组中，以便降低在排序的内循环中访问元素所需要的开销。这是出于性能考虑的做法，但是，它增加了一项优势：即使排序失败，它也能保证输入列表保持原样。

     虽然一般情况下都希望实现失败原子性，但并非总是可以做到。例如，如果两个线程企图在没有适当的同步机制的情况下，并发地修改同一个对象，这个对象就有可能被留在不一致的状态之中。因此，在捕获了ConcurrentModificationException异常之后再假设对象仍然是可用的，这就是不正确的。错误（相对于异常）通常是不可恢复的，当方法抛出错误时，它们不需要努力保持失败原子性。


65 ： 不要忽略异常

    尽管这条建议看上去是显而易见的，但是它却常常被违反，因而值得再次提出来，当API的设计者声明一个方法将抛出某个异常的时候，他们等于正在试图说明某些事情。所以，请不要忽略它！要忽略一个异常非常容易，只需将方法调用通过try语句包围起来，并包含一个空的catch块。

    空的catch块会使异常达不到应有的目的，即强迫你处理导常的情况。忽略异常就如同忽略火警信号一样——若把火警信号器关掉了，当真正的火灾发生时，就没有人能看到火警信号了。或许你会侥幸逃过劫难，或许结果将是灾难性的。每当见到空的catch块时，应该警钟长鸣，至少，catch块也应该包含一条说明，解释为什么可以忽略这个异常。    

    有一种情形可以忽略样常，即关闭FileInputStream的时候。因为你还没有改变文件的状态,因此不必执行任何恢复动作。并目已经从文件中读取到所需要的信息，因此不必终止正在进行的操作。即使在这种情况下，把异常记录下来还是明智的做法，因为如果这些异常经常发生.你就可以调査异常的原因。       

    本条目中的建议同样适用于受检异常和未受检的异常，不管异常代表了可预见的异常条件，还是编程错误，用空的catch块忽略它，将会导致程序在遇到错误的情况下悄然地执行下去。然后，有可能在将来的某个点上，当程序不能再容忍与错误源明显相关的问题时，它就会头失败。正确地处理异常能够彻底挽回失败。只要将异常传播给外界，至少会导致程序迅速地失败，从而保留了有助于调试该失败条件的信息。

